<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Chris Parnin</title>
    <description>Chris Parnin</description>
    <link>http://chrisparnin.github.io</link>
    <pubDate>2013-11-14</pubDate>
    <item>
      <title>Api Diaries - Twilio</title>
      <link>http://chrisparnin.github.io/articles/2013/05/api-diaries-twilio</link>
      <pubDate>2013-05-20</pubDate>
      <description>&lt;p&gt;&lt;a href="http://www.twilio.com/"&gt;Twilio&lt;/a&gt; makes telephony dead simple for developers.  A developer should be able to do cool things with their API, like sending text messages and setting up conference calls in under 5 minutes.  Such a company must live or die on API design.&lt;/p&gt;

&lt;p&gt;I was very fortunate to speak with &lt;a href="https://twitter.com/jf"&gt;Joel Franusic&lt;/a&gt; to learn how Twilio engages and understands developers when building their API. The following is a based on our conversation:&lt;/p&gt;

&lt;h3 id="toc_0"&gt;How do they know how to get Api Design right?&lt;/h3&gt;

&lt;h4 id="toc_1"&gt;Monitoring channels&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;quot;We go where we are talked about&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://forum.twilio.com/twilio"&gt;getsatisfaction.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/tagged/twilio"&gt;Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://twitter.com/search/realtime?q=%23twilio"&gt;twitter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.hnsearch.com/search#request/all&amp;amp;q=twilio"&gt;Hacker News&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;email (lots)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example tweets:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If any #nodejs #twilio guys could help debug &lt;a href="https://gist.github.com/1314454"&gt;https://gist.github.com/1314454&lt;/a&gt; and why it&amp;#39;s saying not authenticated when I do the request&lt;/p&gt;

&lt;p&gt;.@twilio Why can&amp;#39;t I send an SMS with the words &amp;quot;need to cancel&amp;quot; in it? I keep getting this error: &lt;a href="http://www.twilio.com/docs/errors/21618"&gt;http://www.twilio.com/docs/errors/21618&lt;/a&gt; #janky&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;There are some challenges with doing this&lt;/strong&gt;.  Currently, these channels are manually monitored by the support team.  Although all channels are attended, the issues and resolutions are not always curated and are often handled in different ways.  At the moment, product review meetings and decisions on customer feedback is based on the &amp;quot;semi-intuitive&amp;quot; recollection of issues, more often than on &amp;quot;hard-data&amp;quot;.&lt;/p&gt;

&lt;h4 id="toc_2"&gt;API Usage data&lt;/h4&gt;

&lt;p&gt;API usage data is used internally to refactor API design and understand their users.  For example, one feature was found to be overly exploited by developers and as a result took too much bandwidth. Developers were using the API to request information about their own data usage (kinda meta).  This was changed to so that they instead &lt;a href="http://www.twilio.com/docs/api/rest/usage-triggers"&gt;register a callback&lt;/a&gt; to know when they are approaching a limit.&lt;/p&gt;

&lt;h4 id="toc_3"&gt;Community building&lt;/h4&gt;

&lt;p&gt;Hackathons, meetups, and live demos are the preferred way to engage with developers.  There is still very much footwork in all this.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Prizes are bullshit.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Developers are often well off and are not always inspired by monetary rewards.  Prizes and contests are not commonly used, but if a prize is given away, items encouraging learning and hacking are used, such as Knuth books or a Raspberry Pi.&lt;/p&gt;

&lt;p&gt;Closed betas are also used, to get early feedback from some of the heaviest (or most vocal) users.  For example, &lt;a href="http://www.kalzumeus.com/2011/12/19/productizing-twilio-applications/"&gt;Patrick McKenzie&lt;/a&gt; was instrumental in calling for a solution for automated testing of twilio apps.  A closed beta was able to iron out many of the details and work for adding &lt;a href="http://www.twilio.com/docs/api/rest/test-credentials"&gt;this feature&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id="toc_4"&gt;Company culture&lt;/h4&gt;

&lt;p&gt;Understanding developers is also ingrained into the company culture.
All new hires spend the first two weeks &lt;a href="http://www.zendesk.com/blog/new-employees-answer-support-tickets"&gt;handling support tickets&lt;/a&gt;.  Any employee (including non-devs) can earn street cred by demoing their own twilio app, earning the right to proudly wear the company&amp;#39;s red track jacket.&lt;/p&gt;

&lt;h2 id="toc_5"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Companies built on apis must make developers happy.  Understanding developer&amp;#39;s opinions, problems, and usage patterns still involve manual collection, on-the-ground engagement, and ad-hoc analytics.  There are many opportunities to learn and make this space better.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Collecting and emailing zipped tool logs from your user in one click</title>
      <link>http://chrisparnin.github.io/articles/2013/11/collecting-and-emailing-zipped-tool-logs-from-your-user-in-one-click</link>
      <pubDate>2013-11-14</pubDate>
      <description>&lt;p&gt;Congratulations your tool has users!  But now you are getting bug reports or issues only happening on their machine.  &lt;/p&gt;

&lt;p&gt;Unfortunately, very few developers will have the time or patience to send poke around or follow instructions for finding your debugging output and sending it to you.  &lt;/p&gt;

&lt;p&gt;This post describes a simple way to reduce the friction just a little bit by zipping up your tool logs, opens an email message, and attaches the zip to the email.  From the user&amp;#39;s perspective, this opens up their default email client (e.g. Outlook) addressed to you, with the file attached and a body explaining the tool logs and where they can see the file if needed.  Then, they just have to click send.&lt;/p&gt;

&lt;h2 id="toc_0"&gt;Zipping a file&lt;/h2&gt;

&lt;h4 id="toc_1"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;p&gt;First, setup things on disk. &lt;code&gt;builder&lt;/code&gt; is a StringBuilder that contains the exported contents.  &lt;code&gt;tempExport&lt;/code&gt; is the file we want to zip, as &lt;code&gt;tempExportZip&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var time = DateTime.Now;
string tempExport = System.IO.Path.Combine(m_basePath, &amp;quot;exports&amp;quot;, string.Format(&amp;quot;export-{0:yyyy-MM-dd-hh-mm-tt}.export&amp;quot;, time));
string tempExportZip = System.IO.Path.Combine(m_basePath, &amp;quot;exports&amp;quot;, string.Format(&amp;quot;export-{0:yyyy-MM-dd-hh-mm-tt}.zip&amp;quot;, time));

var parent = System.IO.Path.GetDirectoryName(tempExport);
if (!System.IO.Directory.Exists(parent))
{
    System.IO.Directory.CreateDirectory(parent);
}

System.IO.File.WriteAllText(tempExport, builder.ToString());
Zip.ZipFile(tempExportZip, tempExport);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="toc_2"&gt;automark.VisualStudio/Util/Zip.cs&lt;/h4&gt;

&lt;p&gt;This is a helper class using &lt;code&gt;ZipPackage&lt;/code&gt; to support&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; using System.IO;
 using System.IO.Packaging;

 class Zip
 {
     public static void ZipFile(string zipFilename, string filenameToAdd)
     {
         using (Package zipPackage = ZipPackage.Open(zipFilename, FileMode.OpenOrCreate))
         {
             string destFilename = &amp;quot;.\\&amp;quot; + Path.GetFileName(filenameToAdd);
             Uri zipPartUri = PackUriHelper.CreatePartUri(new Uri(destFilename, UriKind.Relative));

             if (zipPackage.PartExists(zipPartUri))
             {
                 zipPackage.DeletePart(zipPartUri);
             }

             PackagePart zipPackagePart = zipPackage.CreatePart(zipPartUri, &amp;quot;&amp;quot;, CompressionOption.Maximum);
             using (FileStream fileStream = new FileStream(filenameToAdd, FileMode.Open, FileAccess.Read))
             {
                 using (Stream dest = zipPackagePart.GetStream())
                 {
                     fileStream.CopyTo(dest);
                 }
             }
         }
     }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_3"&gt;Sending mail&lt;/h2&gt;

&lt;h4 id="toc_4"&gt;automark.VisualStudio/Util/Mail.cs&lt;/h4&gt;

&lt;p&gt;A helper class for using the &lt;a href="http://msdn.microsoft.com/en-us/library/aa142548(v=exchg.65"&gt;MAPI api&lt;/a&gt;.aspx) for sending an email with Windows default mail client.  Also see this &lt;a href="http://stackoverflow.com/questions/6753008/opening-default-e-mail-program-with-attachment-c"&gt;Stack Overflow Question&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;using System;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;

namespace ninlabs.automark.VisualStudio.Util
{
    public class TestMapiMessageClass
    {
        /// &amp;lt;summary&amp;gt;
        /// Test method to create and show an email
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&amp;quot;args&amp;quot;&amp;gt;&amp;lt;/param&amp;gt;
        static void Main(string[] args)
        {
            MapiMailMessage message = new MapiMailMessage(&amp;quot;Test Message&amp;quot;, &amp;quot;Test Body&amp;quot;);
            message.Recipients.Add(&amp;quot;Test@Test.com&amp;quot;);
            message.Files.Add(@&amp;quot;C:\del.txt&amp;quot;);
            message.ShowDialog();
            Console.ReadLine();
        }
    }

    public delegate void MessageEvent(bool success);

    public class MapiMailMessage
    {

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        private class MapiFileDescriptor
        {
            public int reserved = 0;
            public int flags = 0;
            public int position = 0;
            public string path = null;
            public string name = null;
            public IntPtr type = IntPtr.Zero;
        }

        public enum RecipientType : int
        {
            To = 1,
            CC = 2,
            BCC = 3
        };

        public event MessageEvent OnDone;

        private string _subject;
        private string _body;
        private RecipientCollection _recipientCollection;
        private ArrayList _files;
        private ManualResetEvent _manualResetEvent;

        public MapiMailMessage()
        {
            _files = new ArrayList();
            _recipientCollection = new RecipientCollection();
            _manualResetEvent = new ManualResetEvent(false);
        }

        public MapiMailMessage(string subject)
            : this()
        {
            _subject = subject;
        }

        public MapiMailMessage(string subject, string body)
            : this()
        {
            _subject = subject;
            _body = body;
        }

        public string Subject
        {
            get { return _subject; }
            set { _subject = value; }
        }

        public string Body
        {
            get { return _body; }
            set { _body = value; }
        }

        public RecipientCollection Recipients
        {
            get { return _recipientCollection; }
        }

        public ArrayList Files
        {
            get { return _files; }
        }

        public void ShowDialog()
        {
            // Create the mail message in an STA thread
            Thread t = new Thread(new ThreadStart(_ShowMail));
            t.IsBackground = true;
            t.ApartmentState = ApartmentState.STA;
            t.Start();

            // only return when the new thread has built it&amp;#39;s interop representation
            _manualResetEvent.WaitOne();
            _manualResetEvent.Reset();
        }

        private void _ShowMail(object ignore)
        {
            MAPIHelperInterop.MapiMessage message = new MAPIHelperInterop.MapiMessage();

            using (RecipientCollection.InteropRecipientCollection interopRecipients
                        = _recipientCollection.GetInteropRepresentation())
            {

                message.Subject = _subject;
                message.NoteText = _body;

                message.Recipients = interopRecipients.Handle;
                message.RecipientCount = _recipientCollection.Count;

                // Check if we need to add attachments
                if (_files.Count &amp;gt; 0)
                {
                    // Add attachments
                    message.Files = _AllocAttachments(out message.FileCount);
                }

                // Signal the creating thread (make the remaining code async)
                _manualResetEvent.Set();

                const int MAPI_DIALOG = 0x8;
                //const int MAPI_LOGON_UI = 0x1;
                const int SUCCESS_SUCCESS = 0;
                int error = MAPIHelperInterop.MAPISendMail(IntPtr.Zero, IntPtr.Zero, message, MAPI_DIALOG, 0);

                if (_files.Count &amp;gt; 0)
                {
                    // Deallocate the files
                    _DeallocFiles(message);
                }

                // Check for error
                if (error != SUCCESS_SUCCESS)
                {
                    _LogErrorMapi(error);
                }

                if (OnDone != null)
                {
                    OnDone(error == SUCCESS_SUCCESS || error == 1 /*MAPI_USER_ABORT*/);
                }
            }
        }

        private void _DeallocFiles(MAPIHelperInterop.MapiMessage message)
        {
            if (message.Files != IntPtr.Zero)
            {
                Type fileDescType = typeof(MapiFileDescriptor);
                int fsize = Marshal.SizeOf(fileDescType);

                // Get the ptr to the files
                int runptr = (int)message.Files;
                // Release each file
                for (int i = 0; i &amp;lt; message.FileCount; i++)
                {
                    Marshal.DestroyStructure((IntPtr)runptr, fileDescType);
                    runptr += fsize;
                }
                // Release the file
                Marshal.FreeHGlobal(message.Files);
            }
        }

        private IntPtr _AllocAttachments(out int fileCount)
        {
            fileCount = 0;
            if (_files == null)
            {
                return IntPtr.Zero;
            }
            if ((_files.Count &amp;lt;= 0) || (_files.Count &amp;gt; 100))
            {
                return IntPtr.Zero;
            }

            Type atype = typeof(MapiFileDescriptor);
            int asize = Marshal.SizeOf(atype);
            IntPtr ptra = Marshal.AllocHGlobal(_files.Count * asize);

            MapiFileDescriptor mfd = new MapiFileDescriptor();
            mfd.position = -1;
            int runptr = (int)ptra;
            for (int i = 0; i &amp;lt; _files.Count; i++)
            {
                string path = _files[i] as string;
                mfd.name = Path.GetFileName(path);
                mfd.path = path;
                Marshal.StructureToPtr(mfd, (IntPtr)runptr, false);
                runptr += asize;
            }

            fileCount = _files.Count;
            return ptra;
        }

        /// &amp;lt;summary&amp;gt;
        /// Sends the mail message.
        /// &amp;lt;/summary&amp;gt;
        private void _ShowMail()
        {
            _ShowMail(null);
        }

        /// &amp;lt;summary&amp;gt;
        /// Logs any Mapi errors.
        /// &amp;lt;/summary&amp;gt;
        private void _LogErrorMapi(int errorCode)
        {
            const int MAPI_USER_ABORT = 1;
            const int MAPI_E_FAILURE = 2;
            const int MAPI_E_LOGIN_FAILURE = 3;
            const int MAPI_E_DISK_FULL = 4;
            const int MAPI_E_INSUFFICIENT_MEMORY = 5;
            const int MAPI_E_BLK_TOO_SMALL = 6;
            const int MAPI_E_TOO_MANY_SESSIONS = 8;
            const int MAPI_E_TOO_MANY_FILES = 9;
            const int MAPI_E_TOO_MANY_RECIPIENTS = 10;
            const int MAPI_E_ATTACHMENT_NOT_FOUND = 11;
            const int MAPI_E_ATTACHMENT_OPEN_FAILURE = 12;
            const int MAPI_E_ATTACHMENT_WRITE_FAILURE = 13;
            const int MAPI_E_UNKNOWN_RECIPIENT = 14;
            const int MAPI_E_BAD_RECIPTYPE = 15;
            const int MAPI_E_NO_MESSAGES = 16;
            const int MAPI_E_INVALID_MESSAGE = 17;
            const int MAPI_E_TEXT_TOO_LARGE = 18;
            const int MAPI_E_INVALID_SESSION = 19;
            const int MAPI_E_TYPE_NOT_SUPPORTED = 20;
            const int MAPI_E_AMBIGUOUS_RECIPIENT = 21;
            const int MAPI_E_MESSAGE_IN_USE = 22;
            const int MAPI_E_NETWORK_FAILURE = 23;
            const int MAPI_E_INVALID_EDITFIELDS = 24;
            const int MAPI_E_INVALID_RECIPS = 25;
            const int MAPI_E_NOT_SUPPORTED = 26;
            const int MAPI_E_NO_LIBRARY = 999;
            const int MAPI_E_INVALID_PARAMETER = 998;

            string error = string.Empty;
            switch (errorCode)
            {
                case MAPI_USER_ABORT:
                    error = &amp;quot;User Aborted.&amp;quot;;
                    break;
                case MAPI_E_FAILURE:
                    error = &amp;quot;MAPI Failure.&amp;quot;;
                    break;
                case MAPI_E_LOGIN_FAILURE:
                    error = &amp;quot;Login Failure.&amp;quot;;
                    break;
                case MAPI_E_DISK_FULL:
                    error = &amp;quot;MAPI Disk full.&amp;quot;;
                    break;
                case MAPI_E_INSUFFICIENT_MEMORY:
                    error = &amp;quot;MAPI Insufficient memory.&amp;quot;;
                    break;
                case MAPI_E_BLK_TOO_SMALL:
                    error = &amp;quot;MAPI Block too small.&amp;quot;;
                    break;
                case MAPI_E_TOO_MANY_SESSIONS:
                    error = &amp;quot;MAPI Too many sessions.&amp;quot;;
                    break;
                case MAPI_E_TOO_MANY_FILES:
                    error = &amp;quot;MAPI too many files.&amp;quot;;
                    break;
                case MAPI_E_TOO_MANY_RECIPIENTS:
                    error = &amp;quot;MAPI too many recipients.&amp;quot;;
                    break;
                case MAPI_E_ATTACHMENT_NOT_FOUND:
                    error = &amp;quot;MAPI Attachment not found.&amp;quot;;
                    break;
                case MAPI_E_ATTACHMENT_OPEN_FAILURE:
                    error = &amp;quot;MAPI Attachment open failure.&amp;quot;;
                    break;
                case MAPI_E_ATTACHMENT_WRITE_FAILURE:
                    error = &amp;quot;MAPI Attachment Write Failure.&amp;quot;;
                    break;
                case MAPI_E_UNKNOWN_RECIPIENT:
                    error = &amp;quot;MAPI Unknown recipient.&amp;quot;;
                    break;
                case MAPI_E_BAD_RECIPTYPE:
                    error = &amp;quot;MAPI Bad recipient type.&amp;quot;;
                    break;
                case MAPI_E_NO_MESSAGES:
                    error = &amp;quot;MAPI No messages.&amp;quot;;
                    break;
                case MAPI_E_INVALID_MESSAGE:
                    error = &amp;quot;MAPI Invalid message.&amp;quot;;
                    break;
                case MAPI_E_TEXT_TOO_LARGE:
                    error = &amp;quot;MAPI Text too large.&amp;quot;;
                    break;
                case MAPI_E_INVALID_SESSION:
                    error = &amp;quot;MAPI Invalid session.&amp;quot;;
                    break;
                case MAPI_E_TYPE_NOT_SUPPORTED:
                    error = &amp;quot;MAPI Type not supported.&amp;quot;;
                    break;
                case MAPI_E_AMBIGUOUS_RECIPIENT:
                    error = &amp;quot;MAPI Ambiguous recipient.&amp;quot;;
                    break;
                case MAPI_E_MESSAGE_IN_USE:
                    error = &amp;quot;MAPI Message in use.&amp;quot;;
                    break;
                case MAPI_E_NETWORK_FAILURE:
                    error = &amp;quot;MAPI Network failure.&amp;quot;;
                    break;
                case MAPI_E_INVALID_EDITFIELDS:
                    error = &amp;quot;MAPI Invalid edit fields.&amp;quot;;
                    break;
                case MAPI_E_INVALID_RECIPS:
                    error = &amp;quot;MAPI Invalid Recipients.&amp;quot;;
                    break;
                case MAPI_E_NOT_SUPPORTED:
                    error = &amp;quot;MAPI Not supported.&amp;quot;;
                    break;
                case MAPI_E_NO_LIBRARY:
                    error = &amp;quot;MAPI No Library.&amp;quot;;
                    break;
                case MAPI_E_INVALID_PARAMETER:
                    error = &amp;quot;MAPI Invalid parameter.&amp;quot;;
                    break;
            }

            Debug.WriteLine(&amp;quot;Error sending MAPI Email. Error: &amp;quot; + error + &amp;quot; (code = &amp;quot; + errorCode + &amp;quot;).&amp;quot;);
        }

        internal class MAPIHelperInterop
        {
            private MAPIHelperInterop()
            {
            }

            public const int MAPI_LOGON_UI = 0x1;

            [DllImport(&amp;quot;MAPI32.DLL&amp;quot;, CharSet = CharSet.Ansi)]
            public static extern int MAPILogon(IntPtr hwnd, string prf, string pw, int flg, int rsv, ref IntPtr sess);

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public class MapiMessage
            {
                public int Reserved = 0;
                public string Subject = null;
                public string NoteText = null;
                public string MessageType = null;
                public string DateReceived = null;
                public string ConversationID = null;
                public int Flags = 0;
                public IntPtr Originator = IntPtr.Zero;
                public int RecipientCount = 0;
                public IntPtr Recipients = IntPtr.Zero;
                public int FileCount = 0;
                public IntPtr Files = IntPtr.Zero;
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
            public class MapiRecipDesc
            {
                public int Reserved = 0;
                public int RecipientClass = 0;
                public string Name = null;
                public string Address = null;
                public int eIDSize = 0;
                public IntPtr EntryID = IntPtr.Zero;
            }

            [DllImport(&amp;quot;MAPI32.DLL&amp;quot;)]
            public static extern int MAPISendMail(IntPtr session, IntPtr hwnd, MapiMessage message, int flg, int rsv);
        }
    }

    public class Recipient
    {
        public string Address = null;
        public string DisplayName = null;
        public MapiMailMessage.RecipientType RecipientType = MapiMailMessage.RecipientType.To;

        public Recipient(string address)
        {
            Address = address;
        }

        public Recipient(string address, string displayName)
        {
            Address = address;
            DisplayName = displayName;
        }

        public Recipient(string address, MapiMailMessage.RecipientType recipientType)
        {
            Address = address;
            RecipientType = recipientType;
        }

        public Recipient(string address, string displayName, MapiMailMessage.RecipientType recipientType)
        {
            Address = address;
            DisplayName = displayName;
            RecipientType = recipientType;
        }

        internal MapiMailMessage.MAPIHelperInterop.MapiRecipDesc GetInteropRepresentation()
        {
            MapiMailMessage.MAPIHelperInterop.MapiRecipDesc interop = new MapiMailMessage.MAPIHelperInterop.MapiRecipDesc();

            if (DisplayName == null)
            {
                interop.Name = Address;
            }
            else
            {
                interop.Name = DisplayName;
                interop.Address = Address;
            }

            interop.RecipientClass = (int)RecipientType;

            return interop;
        }
    }
    public class RecipientCollection : CollectionBase
    {
        /// &amp;lt;summary&amp;gt;
        /// Adds the specified recipient to this collection.
        /// &amp;lt;/summary&amp;gt;
        public void Add(Recipient value)
        {
            List.Add(value);
        }

        /// &amp;lt;summary&amp;gt;
        /// Adds a new recipient with the specified address to this collection.
        /// &amp;lt;/summary&amp;gt;
        public void Add(string address)
        {
            this.Add(new Recipient(address));
        }

        /// &amp;lt;summary&amp;gt;
        /// Adds a new recipient with the specified address and display name to this collection.
        /// &amp;lt;/summary&amp;gt;
        public void Add(string address, string displayName)
        {
            this.Add(new Recipient(address, displayName));
        }

        /// &amp;lt;summary&amp;gt;
        /// Adds a new recipient with the specified address and recipient type to this collection.
        /// &amp;lt;/summary&amp;gt;
        public void Add(string address, MapiMailMessage.RecipientType recipientType)
        {
            this.Add(new Recipient(address, recipientType));
        }

        /// &amp;lt;summary&amp;gt;
        /// Adds a new recipient with the specified address, display name and recipient type to this collection.
        /// &amp;lt;/summary&amp;gt;
        public void Add(string address, string displayName, MapiMailMessage.RecipientType recipientType)
        {
            this.Add(new Recipient(address, displayName, recipientType));
        }

        /// &amp;lt;summary&amp;gt;
        /// Returns the recipient stored in this collection at the specified index.
        /// &amp;lt;/summary&amp;gt;
        public Recipient this[int index]
        {
            get
            {
                return (Recipient)List[index];
            }
        }

        internal InteropRecipientCollection GetInteropRepresentation()
        {
            return new InteropRecipientCollection(this);
        }

        internal struct InteropRecipientCollection : IDisposable
        {
            private IntPtr _handle;
            private int _count;

            public InteropRecipientCollection(RecipientCollection outer)
            {
                _count = outer.Count;

                if (_count == 0)
                {
                    _handle = IntPtr.Zero;
                    return;
                }

                // allocate enough memory to hold all recipients
                int size = Marshal.SizeOf(typeof(MapiMailMessage.MAPIHelperInterop.MapiRecipDesc));
                _handle = Marshal.AllocHGlobal(_count * size);

                // place all interop recipients into the memory just allocated
                int ptr = (int)_handle;
                foreach (Recipient native in outer)
                {
                    MapiMailMessage.MAPIHelperInterop.MapiRecipDesc interop = native.GetInteropRepresentation();

                    // stick it in the memory block
                    Marshal.StructureToPtr(interop, (IntPtr)ptr, false);
                    ptr += size;
                }
            }

            public IntPtr Handle
            {
                get { return _handle; }
            }
            public void Dispose()
            {
                if (_handle != IntPtr.Zero)
                {
                    Type type = typeof(MapiMailMessage.MAPIHelperInterop.MapiRecipDesc);
                    int size = Marshal.SizeOf(type);

                    // destroy all the structures in the memory area
                    int ptr = (int)_handle;
                    for (int i = 0; i &amp;lt; _count; i++)
                    {
                        Marshal.DestroyStructure((IntPtr)ptr, type);
                        ptr += size;
                    }

                    // free the memory
                    Marshal.FreeHGlobal(_handle);

                    _handle = IntPtr.Zero;
                    _count = 0;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="toc_5"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;p&gt;Let&amp;#39;s send the message!  As a back-up, we can use the &lt;code&gt;mailto:&lt;/code&gt; protocol if the MAPI api fails.  But we have to access to user to manually attach the zip file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bool triedBackup = false;
try
{
    MapiMailMessage message = new MapiMailMessage(&amp;quot;Automark export&amp;quot;, &amp;quot;This information includes the automark usage log....  This usage info will help in testing and improving the tool. You can review the exported info in &amp;quot; + tempExport + &amp;quot;  \nThanks!&amp;quot;);
    message.Recipients.Add(&amp;quot;me@gmail.com&amp;quot;);
    message.Files.Add(tempExportZip);
    message.OnDone += (success) =&amp;gt;
    {
        if (!success)
        {
            triedBackup = true;
            string msg = @&amp;quot;mailto:me@gmail.com&amp;amp;subject=Automark export&amp;amp;body=Please attach {0} and send.&amp;quot;;
            System.Diagnostics.Process.Start(string.Format(msg, tempExportZip));
        }
    };
    message.ShowDialog();
}
catch (Exception ex)
{
    if (!triedBackup)
    {
        string msg = @&amp;quot;mailto:me@gmail.com&amp;amp;subject=Automark export&amp;amp;body=Please attach {0} and send.&amp;quot;;
        System.Diagnostics.Process.Start(string.Format(msg, tempExportZip));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id="toc_6"&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Reducing friction to feedback helps us get better data. There are some nice ways to extend this.  For example, automatically take a screenshot of buggy behavior and send it over email.  Or file a bug report to github, etc.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Creating a Visual Studio extension shim for automark</title>
      <link>http://chrisparnin.github.io/articles/2013/10/creating-a-visual-studio-extension-shim-for-automark</link>
      <pubDate>2013-10-12</pubDate>
      <description>&lt;p&gt;&lt;code&gt;automark&lt;/code&gt; is a tool for generating a markdown summary of a coding task from recent coding history.  It designed work with another tool, &lt;a href="https://github.com/chrisparnin/autogit"&gt;autogit&lt;/a&gt;, which records fine-grain code changes in the IDE.&lt;/p&gt;

&lt;p&gt;Something a little different about this blog post is that this doesn&amp;#39;t aim to be a perfect &lt;em&gt;how-to&lt;/em&gt; document, but instead, show incremental progress and mistakes along the way.&lt;/p&gt;

&lt;h2 id="toc_0"&gt;Coding Summary, Friday, October 11, 2013&lt;/h2&gt;

&lt;p&gt;I will be showing one example usage of automark, by showing you a blog post generated from a recent coding task.  The &lt;em&gt;goal&lt;/em&gt; of the task was to create a light-weight shim for Visual Studio to run and launch automark, which currently works as a command line tool, from the IDE itself.&lt;/p&gt;

&lt;h3 id="toc_1"&gt;Setting up VSX package&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ProvideAutoLoad&lt;/code&gt; is necessary for getting Visual Studio package to load automatically.&lt;/p&gt;

&lt;h4 id="toc_2"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     // This attribute registers a tool window exposed by this package.
     [ProvideToolWindow(typeof(MyToolWindow))]
     [Guid(GuidList.guidautomarkVisualStudioPkgString)]
+    [ProvideAutoLoad(VSConstants.UICONTEXT.SolutionExists_string)]
     public sealed class automarkVisualStudioPackage : Package
     {
         /// &amp;lt;summary&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code for showing a message box is automatically generated -- extract this out as a method, can use later for debugging and error reporting.&lt;/p&gt;

&lt;h4 id="toc_3"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;         /// &amp;lt;/summary&amp;gt;
         private void MenuItemCallback(object sender, EventArgs e)
         {
         }
+        private void ShowMessage(string title, string message)
+        {
             // Show a Message Box to prove we were here
             IVsUIShell uiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
             Guid clsid = Guid.Empty;
             Microsoft.VisualStudio.ErrorHandler.ThrowOnFailure(uiShell.ShowMessageBox(
                        0,
                        ref clsid,
-                       &amp;quot;automark&amp;quot;,
-                       string.Format(CultureInfo.CurrentCulture, &amp;quot;Inside {0}.MenuItemCallback()&amp;quot;, this.ToString()),
+                       title,
+                       message,
                        string.Empty,
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="toc_4"&gt;Executing command line program and reading its output&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1469764/run-command-prompt-commands"&gt;c# - Run Command Prompt Commands - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Get template code for running an executable for  command prompt.&lt;/p&gt;

&lt;h4 id="toc_5"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;         /// &amp;lt;/summary&amp;gt;
         private void MenuItemCallback(object sender, EventArgs e)
         {
-
+            System.Diagnostics.Process process = new System.Diagnostics.Process();
+            System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
+            startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
+            startInfo.FileName = &amp;quot;automark.exe&amp;quot;;
+            startInfo.Arguments = &amp;quot;C:/DEV/github/automark/Source/Extensions/automark.VisualStudio/.HistoryData/LocalHistory&amp;quot;;
+            process.StartInfo = startInfo;
+            process.Start();
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/864484/getting-the-path-of-the-current-assembly"&gt;getting-the-path-of-the-current-assembly&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thought relative path for running &lt;code&gt;automark.exe&lt;/code&gt;, would work, but need to give it full path.&lt;/p&gt;

&lt;h4 id="toc_6"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;+using System.Reflection;

 namespace ninlabs.automark.VisualStudio
 {
         /// &amp;lt;/summary&amp;gt;
         private void MenuItemCallback(object sender, EventArgs e)
         {
+            string path = (new System.Uri(Assembly.GetExecutingAssembly().CodeBase)).AbsolutePath;
+            string directory = System.IO.Path.GetDirectoryName(path);
+            string executable = System.IO.Path.Combine(directory, &amp;quot;automark.exe&amp;quot;);
             System.Diagnostics.Process process = new System.Diagnostics.Process();
             System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
             startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
-            startInfo.FileName = &amp;quot;automark.exe&amp;quot;;
+            startInfo.FileName = executable;
             startInfo.Arguments = &amp;quot;C:/DEV/github/automark/Source/Extensions/automark.VisualStudio/.HistoryData/LocalHistory&amp;quot;;
             process.StartInfo = startInfo;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/4291912/process-start-how-to-get-the-output"&gt;http://stackoverflow.com/questions/4291912/process-start-how-to-get-the-output&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let&amp;#39;s get the process output.&lt;/p&gt;

&lt;h4 id="toc_7"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;             System.Diagnostics.Process process = new System.Diagnostics.Process();
             System.Diagnostics.ProcessStartInfo startInfo = new System.Diagnostics.ProcessStartInfo();
             startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
+            startInfo.RedirectStandardOutput = true;
             startInfo.FileName = executable;
             startInfo.Arguments = &amp;quot;C:/DEV/github/automark/Source/Extensions/automark.VisualStudio/.HistoryData/LocalHistory&amp;quot;;
             process.StartInfo = startInfo;
             process.Start();
+            while (!process.StandardOutput.EndOfStream)
+            {
+                string line = process.StandardOutput.ReadLine();
+            }
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get the error output too for prosperity sake.&lt;/p&gt;

&lt;h4 id="toc_8"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;+            startInfo.RedirectStandardError = true;
             startInfo.FileName = executable;
             startInfo.Arguments = &amp;quot;C:/DEV/github/automark/Source/Extensions/automark.VisualStudio/.HistoryData/LocalHistory&amp;quot;;
             process.StartInfo = startInfo;
             {
                 string line = process.StandardOutput.ReadLine();
             }
+            while (!process.StandardError.EndOfStream)
+            {
+                string line = process.StandardError.ReadLine();
+            }
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="toc_9"&gt;Getting current solution&lt;/h3&gt;

&lt;p&gt;I&amp;#39;ve been hard coding a test value to the command line tool.
Need to get the solution path, so I can locate it&amp;#39;s local history provided by &lt;a href="https://github.com/chrisparnin/autogit"&gt;autogit&lt;/a&gt;.  You can get this by listening to solution events.&lt;/p&gt;

&lt;p&gt;But, I accidentally implemented &lt;code&gt;IVsSolution&lt;/code&gt;, not &lt;code&gt;IVsSolutionEvents&lt;/code&gt;, which let&amp;#39;s you listen to solution open events, etc.&lt;/p&gt;

&lt;h4 id="toc_10"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     [ProvideToolWindow(typeof(MyToolWindow))]
     [Guid(GuidList.guidautomarkVisualStudioPkgString)]
     [ProvideAutoLoad(VSConstants.UICONTEXT.SolutionExists_string)]
-    public sealed class automarkVisualStudioPackage : Package, IVsSolution
+    public sealed class automarkVisualStudioPackage : Package, IVsSolutionEvents
+
     {
         /// &amp;lt;summary&amp;gt;
         }

-        public int AddVirtualProject(IVsHierarchy pHierarchy, uint grfAddVPFlags)
-        {
-            return VSConstants.S_OK;
-        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To implement &lt;code&gt;IVsSolutionEvents&lt;/code&gt;, you need to return &lt;code&gt;VSConstants.S_OK&lt;/code&gt; if everything goes ok.&lt;/p&gt;

&lt;h4 id="toc_11"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;         public int OnAfterLoadProject(IVsHierarchy pStubHierarchy, IVsHierarchy pRealHierarchy)
         {
-            throw new NotImplementedException();
+            return VSConstants.S_OK;
         }

         public int OnAfterOpenProject(IVsHierarchy pHierarchy, int fAdded)
         {
-            throw new NotImplementedException();
+            return VSConstants.S_OK;
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add solution cookie and subscribe to solution events.&lt;/p&gt;

&lt;h4 id="toc_12"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     [Guid(GuidList.guidautomarkVisualStudioPkgString)]
     [ProvideAutoLoad(VSConstants.UICONTEXT.SolutionExists_string)]
     public sealed class automarkVisualStudioPackage : Package, IVsSolutionEvents
-
     {
+        private uint m_solutionCookie = 0;
+
         /// &amp;lt;summary&amp;gt;
         /// Default constructor of the package.
                 MenuCommand menuToolWin = new MenuCommand(ShowToolWindow, toolwndCommandID);
                 mcs.AddCommand( menuToolWin );
             }
+            IVsSolution solution = (IVsSolution)GetService(typeof(SVsSolution));
+            ErrorHandler.ThrowOnFailure(solution.AdviseSolutionEvents(this, out m_solutionCookie));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copied some code to handle solution path.&lt;/p&gt;

&lt;h4 id="toc_13"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     public sealed class automarkVisualStudioPackage : Package, IVsSolutionEvents
     {
         private uint m_solutionCookie = 0;
+        EnvDTE.DTE m_dte;

         /// &amp;lt;summary&amp;gt;
         /// Default constructor of the package.

         public int OnAfterOpenSolution(object pUnkReserved, int fNewSolution)
         {
+            InitializeWithDTEAndSolutionReady();
             return VSConstants.S_OK;
         }

+        private void InitializeWithDTEAndSolutionReady()
+        {
+            m_dte = (EnvDTE.DTE)this.GetService(typeof(EnvDTE.DTE));
+            if (m_dte == null)
+                ErrorHandler.ThrowOnFailure(1);
+            var solutionBase = &amp;quot;&amp;quot;;
+            var solutionName = &amp;quot;&amp;quot;;
+            if (m_dte.Solution != null)
+            {
+                solutionBase = System.IO.Path.GetDirectoryName(m_dte.Solution.FullName);
+                solutionName = System.IO.Path.GetFileNameWithoutExtension(m_dte.Solution.FullName);
+            }
+            //string dbName = string.Format(&amp;quot;Ganji.History-{0}.sdf&amp;quot;, solutionName);
+            var basePath = PreparePath();
+            var repositoryPath = System.IO.Path.Combine(basePath, &amp;quot;LocalHistory&amp;quot;);
+            var solutionPath = solutionBase;
+            m_saveListener = new SaveListener();
+            m_saveListener.Register(m_dte, repositoryPath, solutionPath);
+        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Tweak to only keep part for finding out local history path.&lt;/p&gt;

&lt;h4 id="toc_14"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     public sealed class automarkVisualStudioPackage : Package, IVsSolutionEvents
     {
         private uint m_solutionCookie = 0;
-        EnvDTE.DTE m_dte;
+        private EnvDTE.DTE m_dte;
+        private string m_localHistoryPath = &amp;quot;&amp;quot;;

         /// &amp;lt;summary&amp;gt;
                 solutionBase = System.IO.Path.GetDirectoryName(m_dte.Solution.FullName);
                 solutionName = System.IO.Path.GetFileNameWithoutExtension(m_dte.Solution.FullName);
             }
-            //string dbName = string.Format(&amp;quot;Ganji.History-{0}.sdf&amp;quot;, solutionName);
+            m_localHistoryPath = FindLocalHistoryPath();
+        }

-            var basePath = PreparePath();
-            var repositoryPath = System.IO.Path.Combine(basePath, &amp;quot;LocalHistory&amp;quot;);
-            var solutionPath = solutionBase;
+        private string FindLocalHistoryPath()
+        {
+            var basePath = System.Environment.GetFolderPath(System.Environment.SpecialFolder.MyDocuments);
+            if (m_dte.Solution != null)
+            {
+                basePath = System.IO.Path.GetDirectoryName(m_dte.Solution.FullName);
+            }
+            basePath = System.IO.Path.Combine(basePath, &amp;quot;.HistoryData&amp;quot;);
+            var contextPath = System.IO.Path.Combine(basePath, &amp;quot;LocalHistory&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Get rid of hard-coded path!&lt;/p&gt;

&lt;h4 id="toc_15"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;             startInfo.FileName = executable;
-            startInfo.Arguments = &amp;quot;C:/DEV/github/automark/Source/Extensions/automark.VisualStudio/.HistoryData/LocalHistory&amp;quot;;
+            startInfo.Arguments = m_localHistoryPath;
             process.StartInfo = startInfo;
             process.Start();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="toc_16"&gt;Write output to file and open in external editor/browser&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/15595823/start-browser-from-windows-service"&gt;c# - Start browser from Windows service - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/11112592/open-html-file-in-c-sharp-application"&gt;Open HTML file in C# application - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Write out the results of command to file, then open file. &lt;/p&gt;

&lt;h4 id="toc_17"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;+using System.Text;

 namespace ninlabs.automark.VisualStudio
 {
             process.StartInfo = startInfo;
             process.Start();

+            StringBuilder builder = new StringBuilder();
             while (!process.StandardOutput.EndOfStream)
             {
                 string line = process.StandardOutput.ReadLine();
+                builder.Append(line);
             }
+            System.IO.File.WriteAllText(&amp;quot;automark-{0:yyyy-MM-dd}.md&amp;quot;, builder.ToString());
+            System.Diagnostics.Process.Start(pathToHtmlFile);

             while (!process.StandardError.EndOfStream)
             {
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/13389074/getting-gccs-output-from-command-line-when-running-it-through-c-sharp"&gt;http://stackoverflow.com/questions/13389074/getting-gccs-output-from-command-line-when-running-it-through-c-sharp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Generate a temp file with a unique file name.&lt;/p&gt;

&lt;h4 id="toc_18"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;                 string line = process.StandardOutput.ReadLine();
                 builder.Append(line);
             }
-            System.IO.File.WriteAllText(&amp;quot;automark-{0:yyyy-MM-dd}.md&amp;quot;, builder.ToString());
-            System.Diagnostics.Process.Start(pathToHtmlFile);
+
+            string tempMD =string.Format(&amp;quot;automark-{0:yyyy-MM-dd-tt}.md&amp;quot;, DateTime.Now);
+            System.IO.File.WriteAllText(tempMD, builder.ToString());
+            System.Diagnostics.Process.Start(tempMD);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to redirect output, it turns out you need to turn off &lt;code&gt;UseShellExecute&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id="toc_19"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;             startInfo.WindowStyle = System.Diagnostics.ProcessWindowStyle.Hidden;
             startInfo.RedirectStandardOutput = true;
             startInfo.RedirectStandardError = true;
+            startInfo.UseShellExecute = false;
             startInfo.FileName = executable;
             startInfo.Arguments = m_localHistoryPath;
             process.StartInfo = startInfo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Something isn&amp;#39;t working, let&amp;#39;s display the error message from command program.&lt;/p&gt;

&lt;h4 id="toc_20"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;             process.StartInfo = startInfo;
             process.Start();

+            StringBuilder buildForError = new StringBuilder();
+            while (!process.StandardError.EndOfStream)
+            {
+                string line = process.StandardError.ReadLine();
+                buildForError.Append(line);
+            }
+            var error = buildForError.ToString();
+            if (error.Trim().Length &amp;gt; 0)
+            {
+                ShowMessage(&amp;quot;automark&amp;quot;, error);
+            }
             StringBuilder builder = new StringBuilder();
             while (!process.StandardOutput.EndOfStream)
             {
             string tempMD =string.Format(&amp;quot;automark-{0:yyyy-MM-dd-tt}.md&amp;quot;, DateTime.Now);
             System.IO.File.WriteAllText(tempMD, builder.ToString());
             System.Diagnostics.Process.Start(tempMD);
-            while (!process.StandardError.EndOfStream)
-            {
-                string line = process.StandardError.ReadLine();
-            }
         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops.  The path had &lt;strong&gt;spaces&lt;/strong&gt; in it, which was being interpreted as multiple command line arguments.&lt;/p&gt;

&lt;h4 id="toc_21"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;             startInfo.RedirectStandardError = true;
             startInfo.UseShellExecute = false;
             startInfo.FileName = executable;
-            startInfo.Arguments = m_localHistoryPath;
+            startInfo.Arguments = &amp;#39;&amp;quot;&amp;#39; + m_localHistoryPath + &amp;#39;&amp;quot;&amp;#39;;
             process.StartInfo = startInfo;
             process.Start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok.  But now the execution is &lt;strong&gt;hanging&lt;/strong&gt;!  Turns out you should read &lt;code&gt;StandardOutput&lt;/code&gt; before &lt;code&gt;StandardError&lt;/code&gt; otherwise, it will just hang forever.&lt;/p&gt;

&lt;h4 id="toc_22"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;             process.StartInfo = startInfo;
             process.Start();

+            StringBuilder builder = new StringBuilder();
+            while (!process.StandardOutput.EndOfStream)
+            {
+                string line = process.StandardOutput.ReadLine();
+                builder.Append(line);
+            }

-            StringBuilder builder = new StringBuilder();
-            while (!process.StandardOutput.EndOfStream)
-            {
-                string line = process.StandardOutput.ReadLine();
-                builder.Append(line);
-            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, output!  But &lt;code&gt;ReadLine&lt;/code&gt; was eating up the newline character, need to add it back.&lt;/p&gt;

&lt;h4 id="toc_23"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;             while (!process.StandardOutput.EndOfStream)
             {
                 string line = process.StandardOutput.ReadLine();
-                builder.Append(line);
+                builder.AppendLine(line);
             }

             StringBuilder buildForError = new StringBuilder();
             while (!process.StandardError.EndOfStream)
             {
                 string line = process.StandardError.ReadLine();
-                buildForError.Append(line);
+                buildForError.AppendLine(line);
             }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;tt&lt;/code&gt; actually only outputs &lt;code&gt;PM&lt;/code&gt; or &lt;code&gt;AM&lt;/code&gt;.  Need to add hour and minute too.&lt;/p&gt;

&lt;h4 id="toc_24"&gt;automark.VisualStudio/automark.VisualStudioPackage.cs&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;-            string tempMD =string.Format(&amp;quot;automark-{0:yyyy-MM-dd-tt}.md&amp;quot;, DateTime.Now);
+            string tempMD =string.Format(&amp;quot;automark-{0:yyyy-MM-dd-hh-mm-tt}.md&amp;quot;, DateTime.Now);
             System.IO.File.WriteAllText(tempMD, builder.ToString());
             System.Diagnostics.Process.Start(tempMD);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="toc_25"&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;You just watched how this file got generated from a Visual Studio extension that ran the result of a command line tool for extracting diffs from a local git repository and from Chrome visits to Stack Overflow, and turn it into markdown, suitable for publishing a blog post!&lt;/p&gt;

&lt;p&gt;You can give &lt;a href="https://github.com/chrisparnin/automark"&gt;automark&lt;/a&gt; a shot yourself!&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Deploying native binaries with Visual Studio extensions</title>
      <link>http://chrisparnin.github.io/articles/2013/09/deploying-native-binaries-with-visual-studio-extensions</link>
      <pubDate>2013-09-17</pubDate>
      <description>&lt;h3 id="toc_0"&gt;Deploying Native Binaries&lt;/h3&gt;

&lt;p&gt;If your extension depends on a native binary, you have to do some tricks to get the binary to be copied into the experimental hive directory for testing and including in your VSIX for deployment.&lt;/p&gt;

&lt;p&gt;I was doing some manual copies in my post build event that was brittle, and had to explicitly include the native binaries as &lt;code&gt;content&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="toc_1"&gt;Another way&lt;/h3&gt;

&lt;p&gt;&lt;a href="https://github.com/nulltoken"&gt;nulltoken&lt;/a&gt; had given out a helpful hint on using msbuild directives to stream-line this process:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You might be willing to glance at
&lt;a href="https://github.com/libgit2/libgit2sharp/blob/vNext/LibGit2Sharp/CopyNativeDependencies.targets"&gt;https://github.com/libgit2/libgit2sharp/blob/vNext/LibGit2Sharp/CopyNativeDependencies.targets&lt;/a&gt; and the way it&amp;#39;s being used in &lt;code&gt;LibGit2Sharp.Tests.csproj&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="toc_2"&gt;How to do it&lt;/h3&gt;

&lt;p&gt;I adapted this approach for my project. First, I define a reference to native binaries that live in the nuget directory.  &lt;code&gt;$(MSBuildProjectDirectory)&lt;/code&gt; refers to directory containing the .csproj file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;PropertyGroup&amp;gt;
    &amp;lt;NativeBinariesDirectory&amp;gt;$(MSBuildProjectDirectory)\..\packages\LibGit2Sharp.0.13.0.0\NativeBinaries&amp;lt;/NativeBinariesDirectory&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The nice thing about using MSBuild directives is that you can use pattern matching to include files.
&lt;code&gt;$(NativeBinariesDirectory)\**\*.*&amp;quot;&lt;/code&gt; specifies all the native files I want to include in the project.
The &lt;code&gt;Link&lt;/code&gt; directive describes how the file is displayed in the solution explorer.  &lt;code&gt;CopyToOutputDirectory&lt;/code&gt; is used to copy the binaries in the output bin directory (but not vsix).  &lt;code&gt;IncludeInVSIX&lt;/code&gt; is what makes sure these files will be included in the experimental hive extension folder as well as the packaged .VSIX file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;Content Include=&amp;quot;$(NativeBinariesDirectory)\**\*.*&amp;quot;&amp;gt;
        &amp;lt;Link&amp;gt;NativeBinaries\%(RecursiveDir)%(Filename)%(Extension)&amp;lt;/Link&amp;gt;
        &amp;lt;CopyToOutputDirectory&amp;gt;PreserveNewest&amp;lt;/CopyToOutputDirectory&amp;gt;
        &amp;lt;IncludeInVSIX&amp;gt;true&amp;lt;/IncludeInVSIX&amp;gt;
    &amp;lt;/Content&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="toc_3"&gt;In conclusion&lt;/h3&gt;

&lt;p&gt;Finally, I initially tried nulltoken&amp;#39;s solution directly, but couldn&amp;#39;t find out how to get it to work in the context of a visual studio extension.&lt;/p&gt;

&lt;p&gt;This was useful for helping me understand some of the concepts: &lt;a href="http://stackoverflow.com/questions/1292351/including-content-files-in-csproj-that-are-outside-the-project-cone"&gt;Relevant Stack Overflow quesition&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Parse git log output in C#</title>
      <link>http://chrisparnin.github.io/articles/2013/09/parse-git-log-output-in-c</link>
      <pubDate>2013-09-05</pubDate>
      <description>&lt;p&gt;A simple example for parsing the output of git log in pure C#.&lt;/p&gt;

&lt;h3 id="toc_0"&gt;Getting git log output&lt;/h3&gt;

&lt;p&gt;Get output of &lt;code&gt;git log --name-status&lt;/code&gt; by specifying path of git repo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public static string ListShaWithFiles(string path)
    {
        var output = RunProcess(string.Format(&amp;quot; --git-dir={0}/.git --work-tree={1} log --name-status&amp;quot;, path.Replace(&amp;quot;\\&amp;quot;, &amp;quot;/&amp;quot;), path.Replace(&amp;quot;\\&amp;quot;, &amp;quot;/&amp;quot;)));
        return output;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helper for getting command line output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private static string RunProcess(string command)
    {
        // Start the child process.
        Process p = new Process();
        // Redirect the output stream of the child process.
        p.StartInfo.UseShellExecute = false;
        p.StartInfo.RedirectStandardOutput = true;
        p.StartInfo.FileName = Config.GitExectuable;
        p.StartInfo.Arguments = command;
        p.Start();
        // Read the output stream first and then wait.
        string output = p.StandardOutput.ReadToEnd();
        p.WaitForExit();
        return output;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="toc_1"&gt;Parse output&lt;/h3&gt;

&lt;p&gt;Basic parse loop for parsing a commit.  Will show how to populate next.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        using (var strReader = new StringReader(output))
        {
            do
            {
                var line = strReader.ReadLine();

                if( line.StartsWith(&amp;quot;commit &amp;quot;) )
                {
                }

                if ( StartsWithHeader(line) )
                {
                }

                if (string.IsNullOrEmpty(line) )
                {
                    // commit message divider
                }

                if (line.Length &amp;gt; 0 &amp;amp;&amp;amp; line[0] == &amp;#39;\t&amp;#39;)
                { 
                    // commit message.
                }

                if (line.Length &amp;gt; 1 &amp;amp;&amp;amp; Char.IsLetter(line[0]) &amp;amp;&amp;amp; line[1] == &amp;#39;\t&amp;#39;)
                {
                    // file status
                }
            }
            while (strReader.Peek() != -1);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helper function to help check if a line is a header.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private bool StartsWithHeader(string line)
    {
        if( line.Length &amp;gt; 0 &amp;amp;&amp;amp; char.IsLetter( line[0] ) )
        {
            var seq = line.SkipWhile( ch =&amp;gt; Char.IsLetter(ch) &amp;amp;&amp;amp; ch != &amp;#39;:&amp;#39; );
            return seq.FirstOrDefault() == &amp;#39;:&amp;#39;;
        }
        return false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="toc_2"&gt;Storing results.&lt;/h3&gt;

&lt;p&gt;Class for holding commits &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class GitCommit
{
    public GitCommit()
    {
        Headers = new Dictionary&amp;lt;string, string&amp;gt;();
        Files = new List&amp;lt;GitFileStatus&amp;gt;();
        Message = &amp;quot;&amp;quot;;
    }

    public Dictionary&amp;lt;string, string&amp;gt; Headers { get; set; }
    public string Sha { get; set; }
    public string Message { get; set; }
    public List&amp;lt;GitFileStatus&amp;gt; Files { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and File status&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class GitFileStatus
{
    public string Status { get; set; }
    public string File { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Populating results&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        GitCommit commit = null;
        var commits = new List&amp;lt;GitCommit&amp;gt;();
        bool processingMessage = false;
        using (var strReader = new StringReader(output))
        {
            do
            {
                var line = strReader.ReadLine();

                if( line.StartsWith(&amp;quot;commit &amp;quot;) )
                {
                    if (commit != null)
                        commits.Add(commit);
                    commit = new GitCommit();
                    commit.Sha = line.Split(&amp;#39; &amp;#39;)[1];
                }

                if ( StartsWithHeader(line) )
                {
                    var header = line.Split(&amp;#39;:&amp;#39;)[0];
                    var val = string.Join(&amp;quot;:&amp;quot;,line.Split(&amp;#39;:&amp;#39;).Skip(1)).Trim();

                    // headers
                    commit.Headers.Add(header, val);
                }

                if (string.IsNullOrEmpty(line) )
                {
                    // commit message divider
                    processingMessage = !processingMessage;
                }

                if (line.Length &amp;gt; 0 &amp;amp;&amp;amp; line[0] == &amp;#39;\t&amp;#39;)
                { 
                    // commit message.
                    commit.Message += line;
                }

                if (line.Length &amp;gt; 1 &amp;amp;&amp;amp; Char.IsLetter(line[0]) &amp;amp;&amp;amp; line[1] == &amp;#39;\t&amp;#39;)
                {
                    var status = line.Split(&amp;#39;\t&amp;#39;)[0];
                    var file = line.Split(&amp;#39;\t&amp;#39;)[1];
                    commit.Files.Add(new GitFileStatus() { Status = status, File = file } );
                }
            }
            while (strReader.Peek() != -1);
        }
        if (commit != null)
            commits.Add(commit);

        return commits;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="toc_3"&gt;Run it all and print back results&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    string path = @&amp;quot;C:\DEV\github\Codegrams&amp;quot;;
    if (args.Length &amp;gt; 0)
        path = args[0];
    var output = GitCommands.ListShaWithFiles(path);

    var parser = new ParseGitLog();
    var commits = parser.Parse(output);

    Console.WriteLine(commits.Count);
    foreach (var commit in commits)
    {
        commit.Print();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Print helper&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Print()
    {
        Console.WriteLine(&amp;quot;commit &amp;quot; + Sha);
        foreach (var key in Headers.Keys)
        {
            Console.WriteLine(key + &amp;quot;:&amp;quot; + Headers[key]);
        }
        Console.WriteLine();
        Console.WriteLine(Message);
        Console.WriteLine();
        foreach (var file in Files)
        {
            Console.WriteLine(file.Status + &amp;quot;\t&amp;quot; + file.File);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>Using Tagging and Adornments for better TODOs in Visual Studio.</title>
      <link>http://chrisparnin.github.io/articles/2013/09/using-tagging-and-adornments-for-better-todos-in-visual-studio</link>
      <pubDate>2013-09-27</pubDate>
      <description>&lt;p&gt;Visual Studio actually provides a powerful framework for making custom extensions to the editor while keeping the code surprisingly simple. &lt;/p&gt;

&lt;p&gt;Imagine if you wanted to make a &lt;code&gt;// TODO&lt;/code&gt; note appear more distinctive as well as provide custom actions.&lt;/p&gt;

&lt;p&gt;&lt;img src="/articles/assets/media/todo-ex.png" alt="TodoExample"&gt;&lt;/p&gt;

&lt;p&gt;With Visual Studio Extensions and MEF, you can make direct graphical changes to the editor with an &lt;code&gt;IAdornmentLayer&lt;/code&gt;. But if you want to support custom editor actions and more interactivity, it is worth it to also create an &lt;code&gt;ITagger&lt;/code&gt;. This post will show how you can insert tags into the &lt;code&gt;TextBuffer&lt;/code&gt; and query those to render custom adornments.&lt;/p&gt;

&lt;h4 id="toc_0"&gt;Adornments&lt;/h4&gt;

&lt;p&gt;First, we create a class that will respond to text view creation events and create an &lt;code&gt;IAdornmentLayer&lt;/code&gt;&lt;/p&gt;

&lt;h5 id="toc_1"&gt;TodoArdornmentFactory.cs&lt;/h5&gt;

&lt;p&gt;We provide MEF attributes so that the class will merge into the  &lt;code&gt;IWpfTextViewCreationListener&lt;/code&gt; MEF container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// Establishes an &amp;lt;see cref=&amp;quot;IAdornmentLayer&amp;quot;/&amp;gt; to place the adornment on and exports the &amp;lt;see cref=&amp;quot;IWpfTextViewCreationListener&amp;quot;/&amp;gt;
/// that instantiates the adornment on the event of a &amp;lt;see cref=&amp;quot;IWpfTextView&amp;quot;/&amp;gt;&amp;#39;s creation
/// &amp;lt;/summary&amp;gt;
[Export(typeof(IWpfTextViewCreationListener))]
[ContentType(&amp;quot;text&amp;quot;)]
[TextViewRole(PredefinedTextViewRoles.Document)]
internal sealed class TodoArdornmentFactory : IWpfTextViewCreationListener
{
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MEF magic that will provide the adornment layer we can use when drawing adornments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// Defines the adornment layer for the adornment. This layer is ordered 
    /// after the selection layer in the Z-order
    /// &amp;lt;/summary&amp;gt;
    [Export(typeof(AdornmentLayerDefinition))]
    [Name(&amp;quot;TodoArdornment&amp;quot;)]
    [Order(After = PredefinedAdornmentLayers.Selection, Before = PredefinedAdornmentLayers.Text)]
    [TextViewRole(PredefinedTextViewRoles.Document)]
    public AdornmentLayerDefinition editorAdornmentLayer = null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a new Adornment in response to text view creation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void TextViewCreated(IWpfTextView textView)
    {
        new TodoArdornment(textView);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="toc_2"&gt;TodoArdornment.cs&lt;/h5&gt;

&lt;p&gt;Code responsible for deciding where to drawn adornments over text buffer and how to draw it.&lt;/p&gt;

&lt;p&gt;The two most important things we need to handle in the constructor is getting the &lt;code&gt;TodoArdornment&lt;/code&gt; layer we specified in the Factory, and listen for changes to the text editor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public TodoArdornment(IWpfTextView view)
    {
        _view = view;
        _layer = view.GetAdornmentLayer(&amp;quot;TodoArdornment&amp;quot;);

        //Listen to any event that changes the layout (text changes, scrolling, etc)
        _view.LayoutChanged += OnLayoutChanged;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we respond to text editor changes.  Note, this happens a lot, even with simple scrolling!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private void OnLayoutChanged(object sender, TextViewLayoutChangedEventArgs e)
    {
        foreach (ITextViewLine line in e.NewOrReformattedLines)
        {
            this.CreateVisuals(line);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we can scan code in the current viewport and check if it has a TODO.
But first, an aside.  Apparently, it not so simple to get string of text inside of a &lt;code&gt;ITextViewLine&lt;/code&gt;.  Let&amp;#39;s define a method &lt;code&gt;TryGetText&lt;/code&gt; as provided by Jared Parson via twitter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// This will get the text of the ITextView line as it appears in the actual user editable 
    /// document. 
    /// jared parson: https://gist.github.com/4320643
    /// &amp;lt;/summary&amp;gt;
    public static bool TryGetText(IWpfTextView textView, ITextViewLine textViewLine, out string text)
    {
        var extent = textViewLine.Extent;
        var bufferGraph = textView.BufferGraph;
        try
        {
            var collection = bufferGraph.MapDownToSnapshot(extent, SpanTrackingMode.EdgeInclusive, textView.TextSnapshot);
            var span = new SnapshotSpan(collection[0].Start, collection[collection.Count - 1].End);
            //text = span.ToString();
            text = span.GetText();
            return true;
        }
        catch
        {
            text = null;
            return false;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok.  Let&amp;#39;s match the line of text!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Regex todoLineRegex = new Regex(@&amp;quot;\/\/\s*TODO\b&amp;quot;);

    private void CreateVisuals(ITextViewLine line)
    {
        IWpfTextViewLineCollection textViewLines = _view.TextViewLines;
        string text = null;
        if (TryGetText(_view, line, out text))
        {
            var match = todoLineRegex.Match(text);
            if (match.Success)
            {
                int matchStart = line.Start.Position + span.Index;
                var span = new SnapshotSpan(_view.TextSnapshot, Span.FromBounds(matchStart, matchStart + match.Length));
                SetBoundary(textViewLines, span);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;#39;s draw something!!!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void SetBoundary(IWpfTextViewLineCollection textViewLines, SnapshotSpan span)
    {
        Geometry g = textViewLines.GetMarkerGeometry(span);
        if (g != null)
        {
            GeometryDrawing drawing = new GeometryDrawing(_brush, _pen, g);
            drawing.Freeze();

            DrawingImage drawingImage = new DrawingImage(drawing);
            drawingImage.Freeze();

            Image image = new Image();
            image.Source = drawingImage;

            //Align the image with the top of the bounds of the text geometry
            Canvas.SetLeft(image, g.Bounds.Left);
            Canvas.SetTop(image, g.Bounds.Top);

            _layer.AddAdornment(AdornmentPositioningBehavior.TextRelative, span, null, image, null);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="toc_3"&gt;Tagging&lt;/h4&gt;

&lt;p&gt;Now, we could stop here if we just want the visual effect.  But if we want to perform actions and other interactions, we need to introduce tagging.&lt;/p&gt;

&lt;p&gt;First we need to make some updates to our previous code, and then introduce  a tag provider, tags, and actions.&lt;/p&gt;

&lt;h5 id="toc_4"&gt;TodoArdornmentFactory.cs&lt;/h5&gt;

&lt;p&gt;This service will be used to help find tags in the editor.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [Import]
    private IViewTagAggregatorFactoryService ViewTagAggregatorFactoryService { get; set; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update to pass in tag factory service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void TextViewCreated(IWpfTextView textView)
    {
        new TodoArdornment(textView, ViewTagAggregatorFactoryService.CreateTagAggregator&amp;lt;TodoGlyphTag&amp;gt;( textView ));
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="toc_5"&gt;TodoArdornment.cs&lt;/h5&gt;

&lt;p&gt;Save tag service.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public TodoArdornment(IWpfTextView view, ITagAggregator&amp;lt;TodoGlyphTag&amp;gt; aggregrator)
    {
        ...
        _createTagAggregator = aggregrator;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of scanning code ourselves, we move that code the the tagger and instead ask the tag service for tags held in the span.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private void CreateVisuals(ITextViewLine line)
    {
        ...
        foreach (var tag in this._createTagAggregator.GetTags(line.Extent))
        {
            foreach (var span in tag.Span.GetSpans(_view.TextSnapshot))
            {
                SetBoundary(textViewLines, span);
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="toc_6"&gt;TodoArdornmentFactory.cs&lt;/h5&gt;

&lt;p&gt;We create a tagger that will be associated with a text view.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Export(typeof(IViewTaggerProvider))]
[ContentType(&amp;quot;text&amp;quot;)]
[Order(Before = &amp;quot;default&amp;quot;)]
[TagType(typeof(TodoGlyphTag))]
internal class TodoTagProvider : IViewTaggerProvider
{
    Dictionary&amp;lt;Microsoft.VisualStudio.Text.Editor.ITextView, TodoTagger&amp;gt; taggers = new Dictionary&amp;lt;Microsoft.VisualStudio.Text.Editor.ITextView, TodoTagger&amp;gt;();

    public ITagger&amp;lt;T&amp;gt; CreateTagger&amp;lt;T&amp;gt;(Microsoft.VisualStudio.Text.Editor.ITextView textView, Microsoft.VisualStudio.Text.ITextBuffer buffer) where T : ITag
    {
        if (buffer == null || textView == null)
        {
            return null;
        }

        //make sure we are tagging only the top buffer 
        if (buffer == textView.TextBuffer)
        {
            if (!taggers.ContainsKey(textView))
            {
                taggers[textView] = new TodoTagger(textView);
            }
            return taggers[textView] as ITagger&amp;lt;T&amp;gt;;
        }
        else return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="toc_7"&gt;TodoGlyphTag.cs&lt;/h5&gt;

&lt;p&gt;Create a Tag class, which doesn&amp;#39;t do much at the moment.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class TodoGlyphTag : SmartTag
{
    public TodoGlyphTag(SmartTagType smartTagType, ReadOnlyCollection&amp;lt;SmartTagActionSet&amp;gt; actionSets)
        : base(smartTagType, actionSets)
    {

    }
    internal void Execute(Point position, FrameworkElement frameworkElement)
    {
        // Smart Tag, Intellisense.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="toc_8"&gt;TodoTagger.cs&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;public class TodoTagger : ITagger&amp;lt;TodoGlyphTag&amp;gt;
{
    public event EventHandler&amp;lt;Microsoft.VisualStudio.Text.SnapshotSpanEventArgs&amp;gt; TagsChanged;
    Regex todoLineRegex = new Regex(@&amp;quot;\/\/\s*TODO\b&amp;quot;);
    ITextView _textView;

    internal TodoTagger(ITextView textView)
    {
        _textView = textView;
        _textView.LayoutChanged += OnLayoutChanged;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We listen and response to &lt;code&gt;_textView.LayoutChanged&lt;/code&gt; and let others that this has caused tags to change.  This lets clients know to call &lt;code&gt;GetTags&lt;/code&gt; so we can give them the newest sets of tags.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private void OnLayoutChanged(object sender, TextViewLayoutChangedEventArgs e)
    {
        foreach (var span in e.NewOrReformattedSpans)
        {
            if (TagsChanged != null)
            {
                TagsChanged(this, new SnapshotSpanEventArgs(span));
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;GetTags&lt;/code&gt; does the basically the same thing that we used to do in TodoAdornment.cs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public IEnumerable&amp;lt;ITagSpan&amp;lt;TodoGlyphTag&amp;gt;&amp;gt; GetTags(Microsoft.VisualStudio.Text.NormalizedSnapshotSpanCollection spans)
    {
        foreach (var span in spans)
        {
            String text = span.GetText();
            var match = todoLineRegex.Match(text);
            if (match.Success)
            {
                var point = span.Start.Add(match.Index);
                var spanNew = new SnapshotSpan(span.Snapshot, new Span(point.Position, match.Length));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now... we want to do something different.  We want to provide a set of actions belonging to the tag, but only if the caret is current on the same line as the tag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                ITextViewLine line = null;
                try
                {
                    line = _textView.Caret.ContainingTextViewLine;
                }
                catch( Exception ex )
                {
                    continue;
                }
                var actions = new ReadOnlyCollection&amp;lt;SmartTagActionSet&amp;gt;(new SmartTagActionSet[]{}.ToList());
                if (line != null &amp;amp;&amp;amp;
                    _textView.Caret.ContainingTextViewLine.ContainsBufferPosition(span.Start))
                {
                     actions = GetSmartTagActions(spanNew);
                }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can create our tag!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                yield return new TagSpan&amp;lt;TodoGlyphTag&amp;gt;(spanNew, 
                    new TodoGlyphTag(SmartTagType.Ephemeral, actions)
                );
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="toc_9"&gt;AttachAction.cs&lt;/h5&gt;

&lt;p&gt;Defining actions that will appear in the menu.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;internal class AttachAction : ISmartTagAction
{
    private ITrackingSpan m_span;
    private string m_upper;
    private string m_display;
    private ITextSnapshot m_snapshot;
    private bool m_enabled = true;

    public AttachAction(ITrackingSpan span)
    {
        m_span = span;
        m_snapshot = span.TextBuffer.CurrentSnapshot;
        m_upper = span.GetText(m_snapshot).ToUpper();
        m_display = &amp;quot;Attach&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This we can use to hook into external services...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public void Invoke()
    {
        // Code for posting reminder to viewport...
        m_enabled = false;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rest of action properties.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    public string DisplayText
    {
        get { return m_display; }
    }
    public ImageSource Icon
    {
        get { return null; }
    }
    public bool IsEnabled
    {
        get { return m_enabled; }
    }

    public ISmartTagSource Source
    {
        get;
        private set;
    }

    public ReadOnlyCollection&amp;lt;SmartTagActionSet&amp;gt; ActionSets
    {
        get { return null; }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id="toc_10"&gt;TodoTagger.cs&lt;/h5&gt;

&lt;p&gt;Back to the Tagger, let&amp;#39;s get our actions for a tag.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private ReadOnlyCollection&amp;lt;SmartTagActionSet&amp;gt; GetSmartTagActions(SnapshotSpan span)
    {
        List&amp;lt;SmartTagActionSet&amp;gt; actionSetList = new List&amp;lt;SmartTagActionSet&amp;gt;();
        List&amp;lt;ISmartTagAction&amp;gt; actionList = new List&amp;lt;ISmartTagAction&amp;gt;();

        ITrackingSpan trackingSpan = span.Snapshot.CreateTrackingSpan(span, SpanTrackingMode.EdgeInclusive);
        actionList.Add(new AttachAction(trackingSpan, this));
        SmartTagActionSet actionSet = new SmartTagActionSet(actionList.AsReadOnly());
        actionSetList.Add(actionSet);
        return actionSetList.AsReadOnly();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="toc_11"&gt;Result&lt;/h4&gt;

&lt;p&gt;&lt;img src="/articles/assets/media/attach.png" alt="attach"&gt;&lt;/p&gt;

&lt;p&gt;Now, we can bring up an menu and use it to do other things, like attach the reminder to viewport, or link it to an external service like &lt;a href="rememberthemilk.com/"&gt;Remember the Milk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src="/articles/assets/media/viewport.png" alt="viewport"&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Why Your Academic Blog Post is Worth $200,000</title>
      <link>http://chrisparnin.github.io/articles/2013/04/why-your-academic-blog-post-is-worth-200-000</link>
      <pubDate>2013-04-23</pubDate>
      <description>&lt;h2 id="toc_0"&gt;Grab your Audience&amp;#39;s Attention.&lt;/h2&gt;

&lt;p&gt;If you do not blog about your research, you might as well take all your papers and burn them right now.
&lt;strong&gt;Because no one will read your paper or remember your talk at a conference.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Not because it isn&amp;#39;t wonderful work, but because human bandwidth is terribly limited. Most new memories will fade after a few hours or days, 
and essentially non-existent after 3 months. In an event as fully packed as a conference, with thousands of people, hundreds of conversations, and dozens of 
presentations, chances are your presentation will be forgotten against all the other competing memories.&lt;/p&gt;

&lt;p&gt;People&amp;#39;s time and attention costs money.  To get your research presented in 20 minutes to room of 100 people, 
costs each person easily $2000 (registeration, airfare, and hotel) to be there.  &lt;strong&gt;Collectively, was your talk well-worth $200,000?&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id="toc_1"&gt;Prepare Takeaways&lt;/h2&gt;

&lt;p&gt;Blogging about your research can spread your message to a much bigger room of people.&lt;br&gt;
But these people do not have 20 minutes, and your writing must reflect that. 
Further, consider how people consume content: You are competing with several other open tabs from facebook, twitter, etc.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Most readers will only spend about 10-30 seconds reading your blog post.&lt;/li&gt;
&lt;li&gt;Stick to only one topic; anything else will derail your message.&lt;/li&gt;
&lt;li&gt;Prepacked takeaway points can be read quickly and spread through social media, reinforcing your message.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;#39;ve reached an additional 100 visitors, then you&amp;#39;ve doubled your audience for very little additional effort.
Chances are you will reap other benefits, including research collaborations, consulting offers, increased citations, and people actually reading your paper.&lt;/p&gt;

&lt;h2 id="toc_2"&gt;Foster comments and discussion&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Software developers will tear your ideas to shreds: This is a good thing.&lt;/strong&gt;  Software developers&amp;#39; discussion of research can be dismissive, deeply critical, fixate to the point of distraction on minor issues, and may not have the best understanding of methodology. But they often have good intution and can ofter perspectives or scenarios you never imagined and are always worth your consideration. Learn to channel these comments into something positive.&lt;/p&gt;

&lt;p&gt;Go where the developers are: reddit, hacker news, twitter, etc. Do not shy away from engaging the community directly. 
Perhaps, start with a small audience, maybe a subreddit related to your topic.  Avoid saturating your social networks,
if you have something worth sharing, even starting with something small, it will spread on its own.  &lt;strong&gt;Be mindful of your social currency: do not expect people to continously tune into your broadcasts.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id="toc_3"&gt;Bonus Round&lt;/h2&gt;

&lt;p&gt;Since you have your audience&amp;#39;s attention, you might as well ask them for something.
They can help out by being &lt;a href="https://chrome.google.com/webstore/detail/docsight/ceacnbgdhcnofnomlkmackaennjfmnpc"&gt;trying out your tool&lt;/a&gt;, &lt;a href="http://www.cc.gatech.edu/%7Evector/donatehistory.html"&gt;contributing data&lt;/a&gt;, commenting below, or checking out other articles:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.felienne.com/?cat=3"&gt;Felienne Herman&amp;#39;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.ninlabs.com"&gt;Ninlabs Research Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.neverworkintheory.org/"&gt;It Will Never Work in Theory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
  </channel>
</rss>
